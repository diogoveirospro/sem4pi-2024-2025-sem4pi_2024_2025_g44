# **US253 - Drone Programming Language Configuration**

## 1. Context

The goal of this task is to allow the specification of a **programming language** for a **drone model** within the system.
This functionality is essential to ensure that drones of different models can be used in formations/shows.

### 1.1 List of Issues

* **Analysis:** ðŸ§ª Done
* **Design:** ðŸ§ª Done
* **Implementation:** ðŸ“Œ Backlog
* **Testing:** ðŸ“Œ Backlog

---

## 2. Requirements

**As** a Drone Technician,
**I want** to specify in the system the programming language used for a drone model,
**So that** drones of this model can be used in formations/shows.

**Note:** A programming language can be supported by multiple drone models.

### **Acceptance Criteria**

* **US253.1** It must be possible to associate a programming language with a drone model.
* **US253.2** The system must validate available drone models and programming languages.
* **US253.3** The system must allow the reutilization of programming languages across multiple models.

**Input Templates**

The following proposal templates were used as the basis for the grammar definition:

- [Drone Programming Language model 01 v1.0.txt](files/Drone_Language/DroneOne%20drone%20programming%20language.txt)
- [Drone Programming Language model 02 v1.0.txt](files/Drone_Language/DroneTwo%20drone%20programming%20language.txt)

---

## 3. Analysis

The grammar is designed to describe the configuration of drone programming languages in a **modular and extensible** way.
It is composed of two main parts:

1. **Language Definition:**
   Allows specification of a programming language.

2. **Model Association:**
   Allows associating drone models to previously defined languages.

The grammar uses terminal categories like `IDENTIFIER` and `STRING` to validate fields.
Recursive rules are used for lists and associations, ensuring flexibility and accuracy.

---

## 4. Design

The grammar was designed to:

* Represent programming language configurations clearly and modularly.
* Validate drone models and programming languages.
* Allow reuse of programming languages across multiple models.
* Ensure scalability for new models and languages.

### Grammar

```
(* Terminals *)
PI = "PI";

(* Program *)
program ::= { statement } ;

(* Statements *)
statement ::= variable_declaration | instruction ;

(* Types *)
type ::= "Position" | "Vector" | "LinearVelocity" | "AngularVelocity" | "Distance" | "Time" ;

(* Variable Declaration *)
variable_declaration ::= type identifier "=" expression ";" ;

(* Identifiers *)
identifier ::= letter , { letter | digit | "_" } ;

(* Instructions *)
instruction ::= 
    "takeOff" "(" expression "," expression ")" ";"
  | "land" "(" expression ")" ";"
  | "move" "(" expression "," expression ")" ";"
  | "move" "(" expression "," expression "," expression ")" ";"
  | "movePath" "(" array_of_positions "," expression ")" ";"
  | "hoover" "(" expression ")" ";"
  | "lightsOn" "(" ")" ";"
  | "lightsOff" "(" ")" ";"
  | "blink" "(" expression ")" ";" ;

(* Expressions *)
expression ::= arithmetic ;

arithmetic ::= term , { ("+" | "-") , term } ;
term       ::= factor , { ("*" | "/") , factor } ;
factor     ::= number
             | PI
             | identifier
             | vector
             | position
             | array_of_positions
             | "(" expression ")" ;

(* Literals Position and Vector *)
position ::= "(" float "," float "," float ")" ;
vector   ::= "(" float "," float "," float ")" ;

(* Arrays of Positions with extra pair of parentheses *)
array_of_positions ::= "(" "(" position , { "," position } ")" ")" ;

(* Lexical Tokens *)
number  ::= float | integer ;
float   ::= digit , { digit } , "." , digit , { digit } ;
integer ::= digit , { digit } ;

(* Characters *)
letter ::= "A".."Z" | "a".."z" ;
digit  ::= "0".."9" ;
```